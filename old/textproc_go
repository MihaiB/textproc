
// EmitLFParagraphContent emits the content of each paragraph
// (excluding the line terminator of the paragraph's last line) as a token.
//
// A paragraph consists of adjacent non-empty lines.
// Lines are terminated by "\n".
func EmitLFParagraphContent(in <-chan rune) <-chan []rune {
	out := make(chan []rune)

	go func() {
		var par []rune

		for line := range EmitLFLineContent(in) {
			if len(line) != 0 {
				if len(par) > 0 {
					par = append(par, '\n')
				}
				par = append(par, line...)
				continue
			}

			if len(par) != 0 {
				out <- par
				par = nil
			}
		}

		if len(par) != 0 {
			out <- par
		}
		close(out)
	}()

	return out
}

// SortLFParagraphsI reads the content of all paragraphs
// excluding the line terminator of a paragraph's last line,
// sorts that content in case-insensitive order,
// joins the items with "\n\n" and adds "\n" after the last item.
//
// A paragraph consists of adjacent non-empty lines.
// Lines are terminated by "\n".
func SortLFParagraphsI(in <-chan rune) <-chan rune {
	out := make(chan rune)

	go func() {
		var paragraphs [][]rune
		for par := range EmitLFParagraphContent(in) {
			paragraphs = append(paragraphs, par)
		}
		sortTextsI(paragraphs)

		for i, par := range paragraphs {
			if i > 0 {
				out <- '\n'
			}
			for _, char := range par {
				out <- char
			}
			out <- '\n'
		}
		close(out)
	}()

	return out
}
