
type textLowercaseT struct {
	text      []rune
	lowercase string
}

func getTextLowercaseT(text []rune) *textLowercaseT {
	lowerRunes := make([]rune, len(text))
	for i := range text {
		lowerRunes[i] = unicode.ToLower(text[i])
	}
	return &textLowercaseT{text, string(lowerRunes)}
}

func sortTextsI(texts [][]rune) {
	lowercaseTexts := make([]*textLowercaseT, len(texts))
	for i := range texts {
		lowercaseTexts[i] = getTextLowercaseT(texts[i])
	}
	sort.SliceStable(lowercaseTexts, func(i, j int) bool {
		return lowercaseTexts[i].lowercase < lowercaseTexts[j].lowercase
	})
	for i := range lowercaseTexts {
		texts[i] = lowercaseTexts[i].text
	}
}

// EmitLFLineContent emits the content of each line
// (excluding the line terminator "\n") as a token.
func EmitLFLineContent(in <-chan rune) <-chan []rune {
	out := make(chan []rune)

	go func() {
		var crt []rune

		for r := range in {
			if r == '\n' {
				out <- crt
				crt = nil
				continue
			}

			crt = append(crt, r)
		}

		if len(crt) > 0 {
			out <- crt
		}
		close(out)
	}()

	return out
}

// SortLFLinesI reads the content of all lines
// excluding the line terminator "\n",
// sorts that content in case-insensitive order
// and adds "\n" after each item.
func SortLFLinesI(in <-chan rune) <-chan rune {
	out := make(chan rune)

	go func() {
		var lines [][]rune
		for line := range EmitLFLineContent(in) {
			lines = append(lines, line)
		}
		sortTextsI(lines)

		for _, line := range lines {
			for _, char := range line {
				out <- char
			}
			out <- '\n'
		}
		close(out)
	}()

	return out
}

// EmitLFParagraphContent emits the content of each paragraph
// (excluding the line terminator of the paragraph's last line) as a token.
//
// A paragraph consists of adjacent non-empty lines.
// Lines are terminated by "\n".
func EmitLFParagraphContent(in <-chan rune) <-chan []rune {
	out := make(chan []rune)

	go func() {
		var par []rune

		for line := range EmitLFLineContent(in) {
			if len(line) != 0 {
				if len(par) > 0 {
					par = append(par, '\n')
				}
				par = append(par, line...)
				continue
			}

			if len(par) != 0 {
				out <- par
				par = nil
			}
		}

		if len(par) != 0 {
			out <- par
		}
		close(out)
	}()

	return out
}

// SortLFParagraphsI reads the content of all paragraphs
// excluding the line terminator of a paragraph's last line,
// sorts that content in case-insensitive order,
// joins the items with "\n\n" and adds "\n" after the last item.
//
// A paragraph consists of adjacent non-empty lines.
// Lines are terminated by "\n".
func SortLFParagraphsI(in <-chan rune) <-chan rune {
	out := make(chan rune)

	go func() {
		var paragraphs [][]rune
		for par := range EmitLFParagraphContent(in) {
			paragraphs = append(paragraphs, par)
		}
		sortTextsI(paragraphs)

		for i, par := range paragraphs {
			if i > 0 {
				out <- '\n'
			}
			for _, char := range par {
				out <- char
			}
			out <- '\n'
		}
		close(out)
	}()

	return out
}
