
func checkReader(t *testing.T, r textproc.Reader, runes []rune, err error) {
	for _, rn := range runes {
		got, gotErr := r.Read()
		if got != rn || gotErr != nil {
			t.Fatal("Want", rn, nil, "got", got, gotErr)
		}
	}
	const errCalls = 3
	for i := 0; i < errCalls; i++ {
		got, gotErr := r.Read()
		if got != 0 || gotErr != err {
			t.Fatal("Want", 0, err, "got", got, gotErr)
		}
	}
}

func checkTokenReader(t *testing.T, r textproc.TokenReader,
	tokens [][]rune, err error) {
	for _, token := range tokens {
		gotToken, gotErr := r.ReadToken()
		if string(gotToken) != string(token) || gotErr != nil {
			t.Fatal("Want", token, nil, "got", gotToken, gotErr)
		}
	}
	const errCalls = 3
	for i := 0; i < errCalls; i++ {
		gotToken, gotErr := r.ReadToken()
		if len(gotToken) > 0 || gotErr != err {
			t.Fatal("Want empty token", err,
				"got", gotToken, gotErr)
		}
	}
}

func copyRunes(runes []rune) []rune {
	return append([]rune{}, runes...)
}

func copyTokens(tokens [][]rune) (result [][]rune) {
	for _, token := range tokens {
		result = append(result, copyRunes(token))
	}
	return
}

func TestNewIoReader(t *testing.T) {
	s := "ğŸ§ğŸš£ğŸ™ŠğŸ˜±ğŸ˜œğŸ˜ğŸ‘½" + string([]rune{utf8.MaxRune})
	r := textproc.NewIoReader(textproc.NewReader(strings.NewReader(s)))
	buf := make([]byte, 3)
	var result []byte
	for {
		n, err := r.Read(buf)
		result = append(result, buf[:n]...)
		if n < len(buf) && len(result) != len(s) {
			t.Fatal("Incomplete intermediate read:", n,
				"bytes, want", len(buf))
		}
		if err != nil {
			if err != io.EOF {
				t.Fatal("want", io.EOF, "got", err)
			}
			break
		}
	}
	if string(result) != s {
		t.Fatal("want", s, "got", result)
	}

	for i := 0; i < 3; i++ {
		n, err := r.Read(buf)
		if n != 0 && err != io.EOF {
			t.Fatal("want", 0, io.EOF, "got", n, err)
		}
	}
}

func TestNewReaderFromRuneErrChanPanic(t *testing.T) {
	runeCh := make(chan rune)
	runes := []rune{'a', 'Ãª'}
	go textproc.SendRunesAndClose(copyRunes(runes), runeCh)

	errCh := make(chan error)
	go close(errCh)

	r := textproc.NewReaderFromRuneErrChan(runeCh, errCh)

	defer func() {
		gotI := recover()
		if gotS, ok := gotI.(string); !ok {
			t.Fatal("Not a string:", gotI)
		} else {
			want := "textproc: nil NewReaderFromRuneErrChan err"
			if gotS != want {
				t.Fatal("Want", want, "got", gotS)
			}
		}
	}()

	checkReader(t, r, runes, errors.New("dummy ignored value"))
}

func TestNewReaderFromRuneErrChan(t *testing.T) {
	for _, want := range []struct {
		runes []rune
		err   error
	}{
		{nil, io.EOF},
		{nil, textproc.ErrInvalidUTF8},
		{[]rune{'Â¡', 0, 'â¸˜'}, io.EOF},
	} {
		runeCh := make(chan rune)
		go textproc.SendRunesAndClose(copyRunes(want.runes), runeCh)

		errCh := make(chan error)
		go func() {
			errCh <- want.err
		}()

		r := textproc.NewReaderFromRuneErrChan(runeCh, errCh)
		checkReader(t, r, want.runes, want.err)
	}
}

func TestNewTokenReaderFromTokenErrChanPanic(t *testing.T) {
	tokenCh := make(chan []rune)
	tokens := [][]rune{[]rune("Hi"), nil, []rune("âœ")}
	go textproc.SendTokensAndClose(copyTokens(tokens), tokenCh)

	errCh := make(chan error)
	go close(errCh)

	r := textproc.NewTokenReaderFromTokenErrChan(tokenCh, errCh)

	defer func() {
		gotI := recover()
		if gotS, ok := gotI.(string); !ok {
			t.Fatal("Not a string:", gotI)
		} else {
			want := "textproc: nil NewTokenReaderFromTokenErrChan err"
			if gotS != want {
				t.Fatal("Want", want, "got", gotS)
			}
		}
	}()
	checkTokenReader(t, r, tokens, errors.New("dummy ignored value"))
}

func TestNewTokenReaderFromTokenErrChan(t *testing.T) {
	for _, want := range []struct {
		tokens [][]rune
		err    error
	}{
		{nil, io.EOF},
		{[][]rune{}, textproc.ErrInvalidUTF8},
		{[][]rune{{'ğ„¢'}, nil, []rune("ğ“Ã·ğ“")}, io.EOF},
	} {
		tokenCh := make(chan []rune)
		go textproc.SendTokensAndClose(copyTokens(want.tokens), tokenCh)

		errCh := make(chan error)
		go func() {
			errCh <- want.err
		}()

		r := textproc.NewTokenReaderFromTokenErrChan(tokenCh, errCh)
		checkTokenReader(t, r, want.tokens, want.err)
	}
}

func TestNewTokenReaderFromTokensErrPanic(t *testing.T) {
	defer func() {
		gotI := recover()
		if gotS, ok := gotI.(string); !ok {
			t.Fatal("Not a string:", gotI)
		} else {
			want := "textproc: nil NewTokenReaderFromTokenErrChan err"
			if gotS != want {
				t.Fatal("Want", want, "got", gotS)
			}
		}
	}()

	tokens := [][]rune{[]rune("hi")}
	r := textproc.NewTokenReaderFromTokensErr(copyTokens(tokens), nil)
	checkTokenReader(t, r, tokens, errors.New("dummy ignored value"))
}

func TestNewTokenReaderFromTokensErr(t *testing.T) {
	for _, tokens := range [][][]rune{
		nil,
		{[]rune(""), []rune("Hej"), []rune("vÃ¤rlden")},
	} {
		err := errors.New("new error value")

		r := textproc.NewTokenReaderFromTokensErr(copyTokens(tokens), err)
		checkTokenReader(t, r, tokens, err)
	}
}

func TestNewReaderFromTokenReader(t *testing.T) {
	for _, tokens := range [][][]rune{
		nil,
		{[]rune("ÃŠÃ´"), []rune(""), nil, []rune("âˆ®â‰¡")},
		{[]rune("ab"), nil, nil, []rune{}},
	} {
		var want []rune
		for _, token := range tokens {
			want = append(want, token...)
		}

		err := errors.New("new error value")

		tr := textproc.NewTokenReaderFromTokensErr(copyTokens(tokens), err)
		r := textproc.NewReaderFromTokenReader(tr)
		checkReader(t, r, want, err)
	}
}

func TestReadAllTokens(t *testing.T) {
	for s, want := range map[string]struct {
		tokens [][]rune
		err    error
	}{
		"":        {nil, io.EOF},
		"Â»\n[}\n": {[][]rune{{'Â»'}, {'[', '}'}}, io.EOF},
	} {
		lineContentR := textproc.LFLineContent(textproc.NewReader(strings.NewReader(s)))
		gotTokens, gotErr := textproc.ReadAllTokens(lineContentR)
		if gotErr != want.err {
			t.Fatal("want", want.err, "got", gotErr)
		}
		if len(gotTokens) != len(want.tokens) {
			t.Fatal("want", len(want.tokens), "tokens, got",
				len(gotTokens))
		}
		for i, gotToken := range gotTokens {
			wantToken := want.tokens[i]
			if string(gotToken) != string(wantToken) {
				t.Fatal("want", wantToken, "got", gotToken)
			}
		}
	}
}

func TestLFLineContent(t *testing.T) {
	for s, want := range map[string]*struct {
		tokens [][]rune
		err    error
	}{
		"":          {nil, io.EOF},
		"Î±":         {[][]rune{[]rune("Î±")}, io.EOF},
		"\r\nÎ²Ã¨\n":  {[][]rune{[]rune("\r"), []rune("Î²Ã¨")}, io.EOF},
		"\n\nz":     {[][]rune{nil, nil, []rune("z")}, io.EOF},
		"Î¶\nÎ¾\xffa": {[][]rune{{'Î¶'}}, textproc.ErrInvalidUTF8},
	} {
		textprocReader := textproc.NewReader(strings.NewReader(s))
		r := textproc.LFLineContent(textprocReader)
		checkTokenReader(t, r, want.tokens, want.err)
	}
}

func TestLFParagraphContent(t *testing.T) {
	for s, want := range map[string]*struct {
		tokens [][]rune
		err    error
	}{
		"": {nil, io.EOF},
		"a\r\nb\n \nc\n\nd": {[][]rune{
			[]rune("a\r\nb\n \nc"),
			[]rune("d")}, io.EOF},
		"\n\nÎ´Ïƒ\n\n\n":  {[][]rune{[]rune("Î´Ïƒ")}, io.EOF},
		"Ã¸\n\nb\nc\xff": {[][]rune{[]rune("Ã¸")}, textproc.ErrInvalidUTF8},
	} {
		textprocReader := textproc.NewReader(strings.NewReader(s))
		r := textproc.LFParagraphContent(textprocReader)
		checkTokenReader(t, r, want.tokens, want.err)
	}
}

func TestSortLFParagraphsI(t *testing.T) {
	for s, want := range map[string]*struct {
		runes []rune
		err   error
	}{
		"":       {nil, io.EOF},
		"\n\n\n": {nil, io.EOF},
		"Par1":   {[]rune("Par1\n"), io.EOF},
		"Hi\nğŸ‘½\n\nalien\n\n\nspace": {
			[]rune("alien\n\nHi\nğŸ‘½\n\nspace\n"), io.EOF},
		"NEON\n\nargon\n\nradon\nxenon\n\nHg\nHe\xffa": {
			[]rune("argon\n\nNEON\n\nradon\nxenon\n"),
			textproc.ErrInvalidUTF8},
	} {
		r := textproc.SortLFParagraphsI(textproc.NewReader(
			strings.NewReader(s)))
		checkReader(t, r, want.runes, want.err)
	}
}

func TestSortLFLinesI(t *testing.T) {
	for s, want := range map[string]struct {
		runes []rune
		err   error
	}{
		"":                       {nil, io.EOF},
		"Q\n\na\nrrr":            {[]rune("\na\nQ\nrrr\n"), io.EOF},
		"second\nfirst\nno\xcc.": {[]rune("first\nsecond\n"), textproc.ErrInvalidUTF8},
		"Bb\nbB\nBB\na\n":        {[]rune("a\nBb\nbB\nBB\n"), io.EOF},
	} {
		r := textproc.SortLFLinesI(textproc.NewReader(strings.NewReader(s)))
		checkReader(t, r, want.runes, want.err)
	}
}
