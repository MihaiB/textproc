func readAll(c <-chan rune) string {
	var runes []rune
	for {
		r, ok := <-c
		if !ok {
			return string(runes)
		}
		runes = append(runes, r)
	}
}

func checkError(t *testing.T, c <-chan error, err error) {
	if got, ok := <-c; !ok {
		t.Fatal("Error channel closed early, expected", err)
	} else if got != err {
		t.Fatal("Want", err, "got", got)
	}

	if got, ok := <-c; ok {
		t.Fatal("Unexpected additional error", got)
	}
}

func checkCatalogueEntry(t *testing.T, name string, inOut map[string]string) {
	for in, out := range inOut {
		runeCh, errCh := textproc.Read(strings.NewReader(in))
		if catEntry, ok := catalogue[name]; !ok {
			t.Fatal("Unknown processor:", name)
		} else {
			runeCh = catEntry.processor(runeCh)
		}

		got := readAll(runeCh)
		if got != out {
			t.Fatalf("Want %#v got %#v", out, got)
		}
		checkError(t, errCh, io.EOF)
	}
}

func TestNorm(t *testing.T) {
	inOut := map[string]string{
		"":      "",
		" \t":   "",
		"a \rb": "a\nb\n",
	}
	checkCatalogueEntry(t, "norm", inOut)
}

func TestParseArgsProcs(t *testing.T) {
	for _, tc := range []struct {
		osArgs        []string
		processorsLen int
	}{
		{[]string{"cmd"}, 0},
		{[]string{"cmd", "lf"}, 1},
		{[]string{"cmd", "lf", "lf"}, 2},
		{[]string{"cmd", "lf", "sortpi", "lf"}, 3},
		{[]string{"cmd", "norm"}, 1},
	} {
		args, err := parseArgs(tc.osArgs)
		if err != nil {
			t.Fatal("Want", nil, "got", err)
		}
		if len(args.processors) != tc.processorsLen {
			t.Fatal("Want", tc.processorsLen,
				"got", len(args.processors))
		}
	}
}
